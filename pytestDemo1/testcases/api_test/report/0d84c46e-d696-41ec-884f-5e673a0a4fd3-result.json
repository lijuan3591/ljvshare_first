{"name": "测试数据：【 {username}，{password}，{except_result}，10000，payorder】", "status": "broken", "statusDetails": {"message": "requests.exceptions.JSONDecodeError: [Errno Expecting value] : 0", "trace": "self = <Response [400]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Returns the json-encoded content of a response, if any.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(\n                        self.content.decode(encoding), **kwargs\n                    )\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n    \n        try:\n>           return complexjson.loads(self.text, **kwargs)\n\nD:\\python\\lib\\site-packages\\requests\\models.py:910: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ns = '', encoding = None, cls = None, object_hook = None, parse_float = None\nparse_int = None, parse_constant = None, object_pairs_hook = None\nuse_decimal = False, kw = {}\n\n    def loads(s, encoding=None, cls=None, object_hook=None, parse_float=None,\n            parse_int=None, parse_constant=None, object_pairs_hook=None,\n            use_decimal=False, **kw):\n        \"\"\"Deserialize ``s`` (a ``str`` or ``unicode`` instance containing a JSON\n        document) to a Python object.\n    \n        *encoding* determines the encoding used to interpret any\n        :class:`bytes` objects decoded by this instance (``'utf-8'`` by\n        default). It has no effect when decoding :class:`unicode` objects.\n    \n        *object_hook*, if specified, will be called with the result of every\n        JSON object decoded and its return value will be used in place of the\n        given :class:`dict`.  This can be used to provide custom\n        deserializations (e.g. to support JSON-RPC class hinting).\n    \n        *object_pairs_hook* is an optional function that will be called with\n        the result of any object literal decode with an ordered list of pairs.\n        The return value of *object_pairs_hook* will be used instead of the\n        :class:`dict`.  This feature can be used to implement custom decoders\n        that rely on the order that the key and value pairs are decoded (for\n        example, :func:`collections.OrderedDict` will remember the order of\n        insertion). If *object_hook* is also defined, the *object_pairs_hook*\n        takes priority.\n    \n        *parse_float*, if specified, will be called with the string of every\n        JSON float to be decoded.  By default, this is equivalent to\n        ``float(num_str)``. This can be used to use another datatype or parser\n        for JSON floats (e.g. :class:`decimal.Decimal`).\n    \n        *parse_int*, if specified, will be called with the string of every\n        JSON int to be decoded.  By default, this is equivalent to\n        ``int(num_str)``.  This can be used to use another datatype or parser\n        for JSON integers (e.g. :class:`float`).\n    \n        *parse_constant*, if specified, will be called with one of the\n        following strings: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``.  This\n        can be used to raise an exception if invalid JSON numbers are\n        encountered.\n    \n        If *use_decimal* is true (default: ``False``) then it implies\n        parse_float=decimal.Decimal for parity with ``dump``.\n    \n        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\n        kwarg. NOTE: You should use *object_hook* or *object_pairs_hook* instead\n        of subclassing whenever possible.\n    \n        \"\"\"\n        if (cls is None and encoding is None and object_hook is None and\n                parse_int is None and parse_float is None and\n                parse_constant is None and object_pairs_hook is None\n                and not use_decimal and not kw):\n>           return _default_decoder.decode(s)\n\nD:\\python\\lib\\site-packages\\simplejson\\__init__.py:525: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <simplejson.decoder.JSONDecoder object at 0x00000140C55E4A58>, s = ''\n_w = <built-in method match of re.Pattern object at 0x00000140C4D93570>\n_PY3 = True\n\n    def decode(self, s, _w=WHITESPACE.match, _PY3=PY3):\n        \"\"\"Return the Python representation of ``s`` (a ``str`` or ``unicode``\n        instance containing a JSON document)\n    \n        \"\"\"\n        if _PY3 and isinstance(s, bytes):\n            s = str(s, self.encoding)\n>       obj, end = self.raw_decode(s)\n\nD:\\python\\lib\\site-packages\\simplejson\\decoder.py:370: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <simplejson.decoder.JSONDecoder object at 0x00000140C55E4A58>, s = ''\nidx = 0, _w = <built-in method match of re.Pattern object at 0x00000140C4D93570>\n_PY3 = True\n\n    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` or ``unicode``\n        beginning with a JSON document) and return a 2-tuple of the Python\n        representation and the index in ``s`` where the document ended.\n        Optionally, ``idx`` can be used to specify an offset in ``s`` where\n        the JSON document begins.\n    \n        This can be used to decode a JSON document from a string that may\n        have extraneous data at the end.\n    \n        \"\"\"\n        if idx < 0:\n            # Ensure that raw_decode bails on negative indexes, the regex\n            # would otherwise mask this behavior. #98\n            raise JSONDecodeError('Expecting value', s, idx)\n        if _PY3 and not isinstance(s, str):\n            raise TypeError(\"Input string must be text, not bytes\")\n        # strip UTF-8 bom\n        if len(s) > idx:\n            ord0 = ord(s[idx])\n            if ord0 == 0xfeff:\n                idx += 1\n            elif ord0 == 0xef and s[idx:idx + 3] == '\\xef\\xbb\\xbf':\n                idx += 3\n>       return self.scan_once(s, idx=_w(s, idx).end())\nE       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\nD:\\python\\lib\\site-packages\\simplejson\\decoder.py:400: JSONDecodeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <testcases.api_test.test_03_login.TestUserLogin object at 0x00000140C605DA58>\nexcept_code = 10000, except_msg = 'payorder'\nheaders = {'Content-Type': 'application/json', 'Referer': 'https://dev2-cashier-uih5.tiens.com/', 'curr_code': 'RUB', 'select_nation_id': 'RU', ...}\nurl = '/cashier/api/pay_channel/select?goodsorderid=${goodsorderid}&language=zh-cn'\nextract = ''\n\n    @allure.story(\"用例--选择支付渠道\")\n    @allure.description(\"该用例是用户登录成功后，选择支付渠道\")\n    @allure.issue(\"https://www.cnblogs.com/wintest\", name=\"点击，跳转到对应BUG的链接地址\")\n    @allure.testcase(\"https://www.cnblogs.com/wintest\", name=\"点击，跳转到对应用例的链接地址\")\n    @allure.title(\"测试数据：【 {username}，{password}，{except_result}，{except_code}，{except_msg}】\")\n    @pytest.mark.single\n    @pytest.mark.parametrize(\"except_code, except_msg, headers, url, extract\",api_data[\"test_select_paychannel\"])\n    def test_select_paychannel(self, except_code, except_msg, headers, url, extract):\n        logger.info(\"*************** 开始执行用例 ***************\")\n        result = select_paychannel(headers, url)\n        step_1(url)\n>       result = result.response.json()\n\ntest_03_login.py:146: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Response [400]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Returns the json-encoded content of a response, if any.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(\n                        self.content.decode(encoding), **kwargs\n                    )\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n    \n        try:\n            return complexjson.loads(self.text, **kwargs)\n        except JSONDecodeError as e:\n            # Catch JSON-related errors and raise as requests.JSONDecodeError\n            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError\n            if is_py2: # e is a ValueError\n                raise RequestsJSONDecodeError(e.message)\n            else:\n>               raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\nE               requests.exceptions.JSONDecodeError: [Errno Expecting value] : 0\n\nD:\\python\\lib\\site-packages\\requests\\models.py:917: JSONDecodeError"}, "description": "该用例是用户登录成功后，选择支付渠道", "steps": [{"name": "步骤1 ==>> 登录用户", "status": "passed", "parameters": [{"name": "username", "value": "'/cashier/api/pay_channel/select?goodsorderid=${goodsorderid}&language=zh-cn'"}], "start": 1669789851910, "stop": 1669789851910}], "attachments": [{"name": "log", "source": "2ea68a98-8f31-44b7-9bd3-88e7dc5dd560-attachment.txt", "type": "text/plain"}], "parameters": [{"name": "except_code", "value": "10000"}, {"name": "except_msg", "value": "'payorder'"}, {"name": "headers", "value": "{'tiens_token': '${tiens_token}', 'user_id': '${user_id}', 'shop_id': 'RU998001', 'shoppingcartid': '-1', 'Content-Type': 'application/json', 'select_nation_id': 'RU', 'curr_code': 'RUB', 'tenant_id': '${tenant_id}', 'tiens_code': '${tiens_code}', 'Referer': 'https://dev2-cashier-uih5.tiens.com/'}"}, {"name": "url", "value": "'/cashier/api/pay_channel/select?goodsorderid=${goodsorderid}&language=zh-cn'"}, {"name": "extract", "value": "''"}], "start": 1669789851875, "stop": 1669789851911, "uuid": "d35d9e1b-aa4c-480f-b13c-71c8a7d9d2f7", "historyId": "0dee953fe309103ed34774bb84fdd6d6", "testCaseId": "24cab1366d295c2eb26d054b84332d30", "fullName": "testcases.api_test.test_03_login.TestUserLogin#test_select_paychannel", "labels": [{"name": "story", "value": "用例--选择支付渠道"}, {"name": "feature", "value": "用户登录模块"}, {"name": "epic", "value": "针对单个接口的测试"}, {"name": "severity", "value": "normal"}, {"name": "tag", "value": "single"}, {"name": "parentSuite", "value": "testcases.api_test"}, {"name": "suite", "value": "test_03_login"}, {"name": "subSuite", "value": "TestUserLogin"}, {"name": "host", "value": "lijuan"}, {"name": "thread", "value": "11556-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "testcases.api_test.test_03_login"}], "links": [{"type": "test_case", "url": "https://www.cnblogs.com/wintest", "name": "点击，跳转到对应用例的链接地址"}, {"type": "issue", "url": "https://www.cnblogs.com/wintest", "name": "点击，跳转到对应BUG的链接地址"}]}